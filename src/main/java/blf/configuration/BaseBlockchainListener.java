package blf.configuration;

import blf.core.state.ProgramState;
import blf.core.Program;
import blf.core.instructions.SetOutputFolderInstruction;
import blf.grammar.BcqlBaseListener;
import blf.grammar.BcqlParser;
import blf.parsing.VariableExistenceListener;
import blf.util.TypeUtils;
import org.antlr.v4.runtime.ParserRuleContext;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Logger;

/**
 * The abstract BaseBlockchainListener class implements blockchain unspecific callback functions, which are triggered
 * when a parse tree walker enters or exits corresponding parse tree nodes. These callback functions handle how the
 * program should process the input of the manifest file.
 *
 * It extends the BcqlBaseListener class, which is an empty listener template generated by ANTLR4 for the grammar.
 */

public abstract class BaseBlockchainListener extends BcqlBaseListener {
    private static final Logger LOGGER = Logger.getLogger(BaseBlockchainListener.class.getName());

    protected Program program;
    protected ProgramState state;
    protected BuildException error;
    protected final VariableExistenceListener variableAnalyzer;
    protected final SpecificationComposer composer = new SpecificationComposer();
    protected final Deque<Object> genericFilterPredicates = new ArrayDeque<>();

    public ProgramState getState() {
        return this.state;
    }

    public Program getProgram() {
        return this.program;
    }

    public BuildException getError() {
        return this.error;
    }

    public boolean containsError() {
        return this.error != null;
    }

    protected BaseBlockchainListener(VariableExistenceListener analyzer) {
        this.variableAnalyzer = analyzer;
    }

    @Override
    public void enterBlockchain(BcqlParser.BlockchainContext ctx) {
        LOGGER.info("Prepare program build");
        this.error = null;
        try {
            this.composer.prepareProgramBuild();
        } catch (BuildException e) {
            LOGGER.severe(String.format("Preparation of program build failed: %s", e.getMessage()));
            System.exit(1);
        }
    }

    @Override
    public void enterOutputFolder(BcqlParser.OutputFolderContext ctx) {
        final BcqlParser.LiteralContext literal = ctx.literal();
        final String literalText = literal.getText();

        if (literal.STRING_LITERAL() == null) {
            LOGGER.severe("SET OUTPUT FOLDER parameter should be a String");
            System.exit(1);
        }

        this.state.outputFolderPath = TypeUtils.parseStringLiteral(literalText);

        this.composer.addInstruction(new SetOutputFolderInstruction());
    }

    @Override
    public void exitDocument(BcqlParser.DocumentContext ctx) {
        LOGGER.info("Build program");
        try {
            this.program = this.composer.buildProgram();
        } catch (BuildException e) {
            LOGGER.severe(String.format("Building program failed: %s", e.getMessage()));
            System.exit(1);
        } finally {
            this.genericFilterPredicates.clear();
        }
    }

    @Override
    public void exitEmitStatementLog(BcqlParser.EmitStatementLogContext ctx) {
        this.handleEmitStatementLog(ctx);
    }

    private void handleEmitStatementLog(BcqlParser.EmitStatementLogContext ctx) {
        final List<ValueAccessorSpecification> accessors = new LinkedList<>();
        try {
            for (BcqlParser.ValueExpressionContext valEx : ctx.valueExpression()) {
                accessors.add(this.getValueAccessor(valEx));
            }
            final LogLineExportSpecification spec = LogLineExportSpecification.ofValues(accessors);
            this.composer.addInstruction(spec);
        } catch (BuildException e) {
            LOGGER.severe(String.format("Handling of emit statement for Log files failed: %s", e.getMessage()));
            System.exit(1);
        }
    }

    @Override
    public void exitEmitStatementCsv(BcqlParser.EmitStatementCsvContext ctx) {
        this.handleEmitStatementCsv(ctx);
    }

    private void handleEmitStatementCsv(BcqlParser.EmitStatementCsvContext ctx) {
        LinkedList<CsvColumnSpecification> columns = new LinkedList<>();
        try {
            for (BcqlParser.NamedEmitVariableContext varCtx : ctx.namedEmitVariable()) {
                final String name = varCtx.valueExpression().variableName() == null
                    ? varCtx.variableName().getText()
                    : varCtx.valueExpression().variableName().getText();
                final ValueAccessorSpecification accessor = this.getValueAccessor(varCtx.valueExpression());
                columns.add(CsvColumnSpecification.of(name, accessor));
            }
            this.composer.addInstruction(CsvExportSpecification.of(this.getValueAccessor(ctx.tableName), columns));
        } catch (BuildException e) {
            LOGGER.severe(String.format("Handling of emit statement for CSV files failed: %s", e.getMessage()));
            System.exit(1);
        }
    }

    @Override
    public void exitEmitStatementXesTrace(BcqlParser.EmitStatementXesTraceContext ctx) {
        this.handleEmitStatementXesTrace(ctx);
    }

    private void handleEmitStatementXesTrace(BcqlParser.EmitStatementXesTraceContext ctx) {
        try {
            final ValueAccessorSpecification pid = this.getXesId(ctx.pid);
            final ValueAccessorSpecification piid = this.getXesId(ctx.piid);
            final List<XesParameterSpecification> parameters = this.getXesParameters(ctx.xesEmitVariable());
            this.composer.addInstruction(XesExportSpecification.ofTraceExport(pid, piid, parameters));
        } catch (BuildException e) {
            LOGGER.severe(String.format("Handling of emit statement for XES trace files failed: %s", e.getMessage()));
            System.exit(1);
        }
    }

    @Override
    public void exitEmitStatementXesEvent(BcqlParser.EmitStatementXesEventContext ctx) {
        this.handleEmitStatementXesEvent(ctx);
    }

    private void handleEmitStatementXesEvent(BcqlParser.EmitStatementXesEventContext ctx) {
        try {
            final ValueAccessorSpecification pid = this.getXesId(ctx.pid);
            final ValueAccessorSpecification piid = this.getXesId(ctx.piid);
            final ValueAccessorSpecification eid = this.getXesId(ctx.eid);
            final List<XesParameterSpecification> parameters = this.getXesParameters(ctx.xesEmitVariable());
            this.composer.addInstruction(XesExportSpecification.ofEventExport(pid, piid, eid, parameters));
        } catch (BuildException e) {
            LOGGER.severe(String.format("Handling of emit statement for XES event files failed: %s", e.getMessage()));
            System.exit(1);
        }
    }

    private ValueAccessorSpecification getXesId(BcqlParser.ValueExpressionContext ctx) {
        return ctx == null ? null : this.getValueAccessor(ctx);
    }

    private List<XesParameterSpecification> getXesParameters(List<BcqlParser.XesEmitVariableContext> variables) {
        final LinkedList<XesParameterSpecification> parameters = new LinkedList<>();
        try {
            for (BcqlParser.XesEmitVariableContext varCtx : variables) {
                final String name = varCtx.variableName() == null
                    ? varCtx.valueExpression().variableName().getText()
                    : varCtx.variableName().getText();
                final ValueAccessorSpecification accessor = this.getValueAccessor(varCtx.valueExpression());
                LOGGER.info(varCtx.getText());

                XesParameterSpecification parameter;
                switch (varCtx.xesTypes().getText()) {
                    case "xs:string":
                        parameter = XesParameterSpecification.ofStringParameter(name, accessor);
                        break;
                    case "xs:date":
                        parameter = XesParameterSpecification.ofDateParameter(name, accessor);
                        break;
                    case "xs:int":
                        parameter = XesParameterSpecification.ofIntegerParameter(name, accessor);
                        break;
                    case "xs:float":
                        parameter = XesParameterSpecification.ofFloatParameter(name, accessor);
                        break;
                    case "xs:boolean":
                        parameter = XesParameterSpecification.ofBooleanParameter(name, accessor);
                        break;
                    default:
                        throw new BuildException(String.format("Xes type '%s' not supported", varCtx.xesTypes().getText()));
                }
                parameters.add(parameter);
            }

            return parameters;
        } catch (BuildException e) {
            LOGGER.severe(String.format("Getter of XES parameters failed: %s", e.getMessage()));
            System.exit(1);
            return null;
        }
    }

    // Utils

    public ValueAccessorSpecification getValueAccessor(BcqlParser.ValueExpressionContext ctx) {
        try {
            if (ctx.variableName() != null) {
                return ValueAccessorSpecification.ofVariable(ctx.getText());
            } else if (ctx.literal() != null) {
                return this.getLiteral(ctx.literal());
            } else {
                throw new UnsupportedOperationException("This value accessor specification is not supported.");
            }
        } catch (UnsupportedOperationException e) {
            LOGGER.severe(String.format("Getter of value accessor failed: %s", e.getMessage()));
            System.exit(1);
            return null;
        }
    }

    public ValueAccessorSpecification getLiteral(BcqlParser.LiteralContext ctx) {
        String type = this.determineLiteralType(ctx);
        return this.getLiteral(type, ctx.getText());
    }

    private String determineLiteralType(BcqlParser.LiteralContext ctx) {
        try {
            String type = null;
            if (ctx.BOOLEAN_LITERAL() != null) {
                type = TypeUtils.BOOL_TYPE_KEYWORD;
            } else if (ctx.BYTES_LITERAL() != null) {
                type = TypeUtils.BYTES_TYPE_KEYWORD;
            } else if (ctx.INT_LITERAL() != null) {
                type = TypeUtils.INT_TYPE_KEYWORD;
            } else if (ctx.STRING_LITERAL() != null) {
                type = TypeUtils.STRING_TYPE_KEYWORD;
            } else if (ctx.arrayLiteral() != null) {
                if (ctx.arrayLiteral().booleanArrayLiteral() != null) {
                    type = TypeUtils.toArrayType(TypeUtils.BOOL_TYPE_KEYWORD);
                } else if (ctx.arrayLiteral().bytesArrayLiteral() != null) {
                    type = TypeUtils.toArrayType(TypeUtils.BYTES_TYPE_KEYWORD);
                } else if (ctx.arrayLiteral().intArrayLiteral() != null) {
                    type = TypeUtils.toArrayType(TypeUtils.INT_TYPE_KEYWORD);
                } else if (ctx.arrayLiteral().stringArrayLiteral() != null) {
                    type = TypeUtils.toArrayType(TypeUtils.STRING_TYPE_KEYWORD);
                }
            }

            if (type == null) {
                throw new BuildException(String.format("Cannot determine type for literal %s.", ctx.getText()));
            }
            return type;
        } catch (BuildException e) {
            LOGGER.severe(String.format("Determination of literal type failed: %s", e.getMessage()));
            System.exit(1);
            return null;
        }

    }

    public ValueAccessorSpecification getLiteral(String type, String literal) {
        try {
            if (TypeUtils.isArrayType(type)) {
                if (TypeUtils.isArrayType(type, TypeUtils.ADDRESS_TYPE_KEYWORD)) {
                    return ValueAccessorSpecification.addressArrayLiteral(literal);
                } else if (TypeUtils.isArrayType(type, TypeUtils.BOOL_TYPE_KEYWORD)) {
                    return ValueAccessorSpecification.booleanArrayLiteral(literal);
                } else if (TypeUtils.isArrayType(type, TypeUtils.BYTES_TYPE_KEYWORD)) {
                    return ValueAccessorSpecification.bytesArrayLiteral(literal);
                } else if (TypeUtils.isArrayType(type, TypeUtils.INT_TYPE_KEYWORD)) {
                    return ValueAccessorSpecification.integerArrayLiteral(literal);
                } else if (TypeUtils.isArrayType(type, TypeUtils.STRING_TYPE_KEYWORD)) {
                    return ValueAccessorSpecification.stringArrayLiteral(literal);
                } else {
                    throw new BuildException(String.format("Unsupported type: '%s'.", type));
                }
            } else {
                if (TypeUtils.isAddressType(type)) {
                    return ValueAccessorSpecification.addressLiteral(literal);
                } else if (TypeUtils.isBooleanType(type)) {
                    return ValueAccessorSpecification.booleanLiteral(literal);
                } else if (TypeUtils.isBytesType(type)) {
                    return ValueAccessorSpecification.bytesLiteral(literal);
                } else if (TypeUtils.isIntegerType(type)) {
                    return ValueAccessorSpecification.integerLiteral(literal);
                } else if (TypeUtils.isStringType(type)) {
                    return ValueAccessorSpecification.stringLiteral(literal);
                } else {
                    throw new BuildException(String.format("Unsupported type: '%s'.", type));
                }
            }
        } catch (BuildException e) {
            LOGGER.severe(String.format("Getter of literal failed: %s", e.getMessage()));
            System.exit(1);
            return null;
        }
    }

    // #endregion Utils
}
