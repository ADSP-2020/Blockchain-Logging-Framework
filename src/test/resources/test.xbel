/* 
configuration section containing
    - definition of output format (XES and potentially CSV)
    - for XES the global, extension, classifier elements
    - for CSV the delimiter (that is a todo)
    - the exception handling (print, ignore, determine)
*/

addExportMode("xes");
registerXESExtension("name", "prefix", "uri", "pid0", "pid1");
registerXESGlobal("name", "type", "value", "scope");
registerXESClassifier("name", "keys", "scope", "pid0");


/*
global variables section
    - variables to e.g., store the smart contract addresses that are queried
    - variables contain no 
    - no limit to the imagination here :)
*/
exceptionHandling = "PRINT";
address[] augurAddresses = {0x1780};



/*
scope section containing
    - scopes following the basic structure 
        BLOCKS* { 
            SCRIPT*
            TRANSACTIONS* { 
                SCRIPT*
                LOG ENTRY* {
                    SCRIPT*
                }
            } 
            SMART CONTRACTS* {
                LOG ENTRY* {
                    SCRIPT*
                }
            }             
        }
*/
BLOCK RANGE (5000000,PENDING) {
    string ident:pid = "network process"; 
	string ident:piid = "block creation";
	string ident:eid = block.number; 
	uint256 time:timestamp = block.timestamp;
    EMIT {
        event(ident:pid, ident:piid, ident:eid, timestamp AS XDATE time:timestamp);
    }

    TRANSACTIONS (ANY) (ANY) {
        EMIT {
            EVENT ("network process" AS ident:pid, block.number AS ident:piid, transaction.number AS ident:eid, transaction.value AS price);
        }        
    }

    SMART CONTRACTS(augurAddresses) {
        LOG ENTRIES (AugurUpdated(address indexed newAddress)) {
            replaceExistingValues(augurAddresses,newAddress);
        }
    }

    SMART CONTRACTS(augurAddresses) {
        uint8 reputationTokens = stateQuery(smartContract, getReputationSum);
        EMIT {
            EVENT("reputation" AS ident:pid, smartContract AS ident:piid, block.number AS ident:eid, reputationTokens AS XINT reputation);
        }

        LOG ENTRIES (string indexed sign, address indexed universe, _, address market, address creator, ...) {
            string ident:pid = universe; 
		    string ident:piid = market;
			string ident:eid = "Created";
			uint256 reputation = stateQuery(0xe99, getReputation, creator);
        
            EMIT IF (isEven(block.number) AND sign == 0xe63e61) {
                EVENT(ident:pid, ident:piid, ident:eid, activityName);
			    TRACE(ident:pid, ident:piid, creator, reputation);
            }
        }
    }
}